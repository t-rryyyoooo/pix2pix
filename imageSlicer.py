import SimpleITK as sitk
import numpy as np
from pathlib import Path
from tqdm import tqdm
import sys
sys.path.append("..")
from utils.patchGenerator.slicePatchGenerator import SlicePatchGenerator
from utils.patchGenerator.utils import calculatePaddingSize
from utils.utils import isMasked, getImageWithMeta
from utils.imageProcessing.padding import paddingForNumpy
from utils.imageProcessing.cropping import croppingForNumpy

class ImageSlicer():
    def __init__(self, input_image, target_image, input_patch_size=None, target_patch_size=None, slide=None, axis=0, mask_image=None):
        """ Slice input and target image perpendicular to axis.

        Parameters: 
            input_image (sitk.Image)  -- An image fed to pix2pix.
            target_image (sitk.Image) -- An image compared to the one generated by pix2pix. 
            input_patch_size (list)   -- patch size for input image array. This list's length equals input_image dimentionality - 1.
            target_patch_size (list)  -- patch size for target image array. This list's length equals target_image dimentionality - 1.
            slide (list)              -- This length equals input_image (target_image) dimentionality -1.
            axis (int)                -- Image array is sliced perpendicular to this axis.
            mask_image (sitk.Image)   -- A binary image array.

        """

        self.org_image  = input_image
        self.axis       = axis
        self.mask_image = mask_image

        self.input_image_array  = sitk.GetArrayFromImage(input_image)
        self.target_image_array = sitk.GetArrayFromImage(target_image)


        if mask_image is None:
            self.mask_image_array = np.ones_like(self.input_image_array)

        else:
            self.mask_image_array = sitk.GetArrayFromImage(mask_image)

        plane_size = self.getPlaneSize(self.input_image_array.shape, axis)

        if input_patch_size is None:
            self.input_patch_size = plane_size
        else:
            self.input_patch_size = np.array(input_patch_size)

        if target_patch_size is None:
            self.target_patch_size = plane_size
        else:
            self.target_patch_size = np.array(target_patch_size)

        if slide is None:
            self.slide = self.target_patch_size 
        else:
            self.slide = np.array(slide)

        assert len(self.input_patch_size) == len(self.target_patch_size) == len(self.slide) == self.input_image_array.ndim - 1


        self.setGenerator()

        """ This line is located after self.setGenerator() because input_image_array is padded in setGenerator. """
        self.predicted_array = np.zeros_like(self.input_image_array, dtype=np.float)

    def __len__(self):
        return self.input_generator.__len__()

    def generatePatchArray(self):
        """ Generator which outputs input, target and mask patch array. """
        for ipa, tpa, mpa in zip(self.input_generator(), self.target_generator(), self.mask_generator()):
            slices= tpa[0] # [0] means slices (clip location).

            yield ipa[1], tpa[1], mpa[1], slices# [1] means patch array because these generator return index and patch_array.
        
    def setGenerator(self):
        """ Caluculate paddingForNumpy size for label and image to clip correctly. """
        self.lower_pad_size, self.upper_pad_size = calculatePaddingSize(
                                                    self.input_image_array.shape,
                                                    np.insert(self.input_patch_size, self.axis, 1),
                                                    np.insert(self.target_patch_size, self.axis, 1),
                                                    np.insert(self.slide, self.axis, 1)
                                                    )

        """ Pad input, target and mask image array. """
        self.input_image_array  = paddingForNumpy(
                                    self.input_image_array,
                                    self.lower_pad_size[0].tolist(),
                                    self.upper_pad_size[0].tolist(),
                                    mirroring = True
                                    )
        self.target_image_array = paddingForNumpy(
                                    self.target_image_array,
                                    self.lower_pad_size[1].tolist(),
                                    self.upper_pad_size[1].tolist(),
                                    mirroring=True
                                    )
        self.mask_image_array   = paddingForNumpy(
                                    self.mask_image_array,
                                    self.lower_pad_size[1].tolist(),
                                    self.upper_pad_size[1].tolist()
                                    )


        """ Set generator for input, target and mask image array. """
        self.input_generator  = SlicePatchGenerator(
                                    self.input_image_array,  
                                    patch_size = self.input_patch_size,
                                    slide      = self.slide,
                                    axis       = self.axis
                                    )
        self.target_generator = SlicePatchGenerator(
                                    self.target_image_array, 
                                    patch_size = self.target_patch_size,
                                    slide      = self.slide,
                                    axis       = self.axis
                                    )
        self.mask_generator   = SlicePatchGenerator(
                                    self.mask_image_array,
                                    patch_size = self.target_patch_size,
                                    slide      = self.slide,
                                    axis       = self.axis
                                    )

    def savePatchArray(self, save_dir, patient_id, input_name="input", target_name="target", with_nonmask=False):
        """ Save patch array to save_path.
        save_path : save_dir / 'all' or 'mask' or 'nonmask' / case_{patient_id} / 'input_name_0000.npy' or 'target_name_0000.npy'

        Parameters: 
            save_dir (str)      -- Refer above.
            patient_id (str)    -- Refer above.
            input_name (str)    -- Input patch array name. Refer above.
            target_name (str)   -- Target patch array name. Refer above.
            with_nonmask (bool) -- Whether you save nonmasked images when mask image is fed.
        """
        save_dir = Path(save_dir)

        if self.mask_image is None:
            save_mask_path = save_dir / "all" / "case_{}".format(str(patient_id).zfill(2)) # When mask_image is None, all of patch arrays are masked.

        else:
            save_mask_path    = save_dir / "mask"    / "case_{}".format(str(patient_id).zfill(2)) 
            save_nonmask_path = save_dir / "nonmask" / "case_{}".format(str(patient_id).zfill(2)) 

        save_mask_path.mkdir(parents=True, exist_ok=True)
        if with_nonmask:
            save_nonmask_path.mkdir(parents=True, exist_ok=True)

        with tqdm(total=self.input_generator.__len__(), desc="Savig patch array...", ncols=60) as pbar:
            for i, (ipa, tpa, mpa, _) in enumerate(self.generatePatchArray()):
                if isMasked(mpa):
                    input_masked_save_path  = save_mask_path / "input_{:04d}.npy".format(i)
                    target_masked_save_path = save_mask_path / "target_{:04d}.npy".format(i)

                    np.save(str(input_masked_save_path),  ipa)
                    np.save(str(target_masked_save_path), tpa)

                else:
                    if with_nonmask:
                        input_nonmasked_save_path  = save_nonmasked_path / "input_{:04d}.npy".format(i)
                        target_nonmasked_save_path = save_nonmasked_path / "target_{:04d}.npy".format(i)

                        np.save(str(input_nonmasked_save_path),  ipa)
                        np.save(str(target_nonmasked_sace_path), tpa)

                pbar.update(1)


    def getPlaneSize(self, image_size, axis):
        """ Output the plane size perpendicular to axis. 

        Parameters:
            image_size (list or np.array) -- image array size
            axis (int)

        Returns: 
            Plane size perpendicular to axis.
        """

        s = np.arange(len(image_size))
        s = np.delete(s, axis)
        plane_size = np.array(image_size)[s]

        return plane_size

    def insertToPredictedArray(self, index, predicted_array):
        """ Insert predicted array (before argmax array) which has probability per class. """

        self.predicted_array[index] += predicted_array

    def outputRestoredImage(self):
        self.predicted_array = croppingForNumpy(
                                self.predicted_array,
                                self.lower_pad_size[1].tolist(),
                                self.upper_pad_size[1].tolist()
                                )

        predicted = getImageWithMeta(self.predicted_array, self.org_image)

        return predicted
                            
                            


